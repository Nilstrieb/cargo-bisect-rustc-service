<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Bisect rustc</title>
    <style>
      html {
        font-family: Arial, Helvetica, sans-serif;
      }

      #result {
        font-family: monospace;
      }

      .hidden {
        display: none;
      }

      #code {
        columns: 100;
      }

      .error {
        color: red;
      }

      .bisect-btn {
        width: 200px;
        height: 50px;
      }
    </style>
  </head>
  <body>
    <h1>Bisect rustc</h1>

    <textarea
      id="code"
      rows="30"
      cols="80"
      placeholder="// Rust code goes here..."
    >
struct Struct&lt;T&gt;(T);

impl&lt;T&gt; Struct&lt;T&gt; {
  const CONST: fn() = || {
      struct _Obligation where T:;
  };
}
</textarea
    >
    <br />
    <label for="start">Start</label>
    <input id="start" value="2022-01-01" />
    <label for="end">End (optional)</label>
    <input id="end" value="2022-06-01" />
    <label for="kind">Regression Kind</label>
    <select id="kind">
      <option>error</option>
      <option>success</option>
      <option selected="selected">ice</option>
      <option>non-ice</option>
      <option>non-error</option>
    </select>

    <br />
    <br />

    <button class="bisect-btn" onclick="bisect()">Bisect!</button>

    <br />
    <br />
    <div id="status" class="hidden"></div>
    <br />
    <textarea
      id="result"
      class="hidden"
      cols="80"
      rows="20"
      readonly
    ></textarea>

    <script>
      const BASE_URL = `${document.location}`;
      const htmlCode = document.getElementById("code");
      const htmlStatus = document.getElementById("status");
      const htmlResult = document.getElementById("result");
      const htmlStart = document.getElementById("start");
      const htmlEnd = document.getElementById("end");
      const htmlKind = document.getElementById("kind");

      let bisecting = false;

      function fatal(err, ...extra) {
        console.error(err, ...(extra || []));
        htmlStatus.innerHTML = `ERROR: ${err}`;
        htmlStatus.classList.remove("hidden");
        htmlStatus.classList.add("error");
        bisecting = false;
      }

      async function bisect() {
        if (bisecting) {
          return;
        }

        if (!htmlStart.value.trim()) {
          fatal("Must provide a start");
          return;
        }

        bisecting = true;

        htmlStatus.classList.remove("error");
        htmlStatus.classList.remove("hidden");
        htmlResult.classList.add("hidden");
        htmlStatus.innerText = "Sending request...";

        const params = new URLSearchParams();

        params.append("start", htmlStart.value.trim());
        params.append("kind", htmlKind.value);

        if (htmlEnd.value.trim()) {
          params.append("end", htmlEnd.value.trim());
        }

        const body = htmlCode.value;

        console.log("Bisecting", body);

        let jobId;
        try {
          const fetched = await fetch(`${BASE_URL}bisect?${params}`, {
            method: "POST",
            body,
            headers: {
              "Content-Type": "application/text",
            },
          });
          if (!fetched.ok) {
            console.error(fetched);
            fatal("Failed to fetch", fetched);
            return;
          }
          const data = await fetched.json();
          jobId = data?.job_id;
          if (!jobId) {
            fatal("Received invalid response", data);
            return;
          }
        } catch (err) {
          fatal(err);
          return;
        }

        async function tryFetch() {
          let response;
          try {
            const fetched = await fetch(`${BASE_URL}bisect/${jobId}`);
            if (!fetched.ok) {
              fatal("Failed to fetch", fetched);
              return;
            }
            response = await fetched.json();
          } catch (e) {
            fatal(e);
            return;
          }

          if (response.status.status !== "InProgress") {
            bisecting = false;
            console.log(response.status.output);

            htmlStatus.classList.add("hidden");
            htmlResult.classList.remove("hidden");

            htmlResult.value = response.status.output;
            htmlStatus.innerHTML = `Bisected job ${jobId}`;
          } else {
            console.log("Waiting for bisection", response.status.status);
            setTimeout(tryFetch, 3000);
          }
        }

        tryFetch();

        htmlStatus.innerHTML = `Waiting for result, job id=${jobId}`;
      }
    </script>
  </body>
</html>
